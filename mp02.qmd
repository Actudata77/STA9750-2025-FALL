---
title: "Mini Project 2: Making Backyards Affordable for All"
author: "Hyacinthe Sarr"
format:
  html:
    toc: true
    toc-title: "Contents"
    number-sections: false
    theme: zephyr
    code-fold: true
    code-summary: "Show code"
execute:
  warning: false
  message: false
---

![](images/yimby.jpg){width="80%" height="auto" fig-align="center"}

## Introduction
Housing affordability is a critical issue affecting millions of people across the United States.
IN this project we will analyze various factors influencing housing affordability, including household income, rent prices, housing supply, and employment wages across different metropolitan areas (CBSAs) over time. WE will use data from the American Community Survey (ACS), Building Permits Survey, and Bureau of Labor Statistics (BLS), to construct indices to measure rent burden and housing stock growth. The insights derived from this analysis will help inform policy decisions and strategies to make housing more affordable for all.


## Data Acquisition

The following code will download all the necessary datasets for this project.

```{r}
#| echo: true
#| message: false
#| warning: false
#| code-fold: true


if(!dir.exists(file.path("data", "mp02"))){
    dir.create(file.path("data", "mp02"), showWarnings=FALSE, recursive=TRUE)
}

ensure_package <- function(pkg){
    pkg <- as.character(substitute(pkg))
    options(repos = c(CRAN = "https://cloud.r-project.org"))
    if(!require(pkg, character.only=TRUE, quietly=TRUE)) install.packages(pkg)
    stopifnot(require(pkg, character.only=TRUE, quietly=TRUE))
}

ensure_package(tidyverse)
ensure_package(glue)
ensure_package(readxl)
ensure_package(tidycensus)

get_acs_all_years <- function(variable, geography="cbsa",
                              start_year=2009, end_year=2023){
    fname <- glue("{variable}_{geography}_{start_year}_{end_year}.csv")
    fname <- file.path("data", "mp02", fname)
    
    if(!file.exists(fname)){
        YEARS <- seq(start_year, end_year)
        YEARS <- YEARS[YEARS != 2020] # Drop 2020 - No survey (covid)
        
        ALL_DATA <- map(YEARS, function(yy){
            tidycensus::get_acs(geography, variable, year=yy, survey="acs1") |>
                mutate(year=yy) |>
                select(-moe, -variable) |>
                rename(!!variable := estimate)
        }) |> bind_rows()
        
        write_csv(ALL_DATA, fname)
    }
    
    read_csv(fname, show_col_types=FALSE)
}

# Household income (12 month)
INCOME <- get_acs_all_years("B19013_001") |>
    rename(household_income = B19013_001)

# Monthly rent
RENT <- get_acs_all_years("B25064_001") |>
    rename(monthly_rent = B25064_001)

# Total population
POPULATION <- get_acs_all_years("B01003_001") |>
    rename(population = B01003_001)

# Total number of households
HOUSEHOLDS <- get_acs_all_years("B11001_001") |>
    rename(households = B11001_001)
    
    
    
get_building_permits <- function(start_year = 2009, end_year = 2023){
    fname <- glue("housing_units_{start_year}_{end_year}.csv")
    fname <- file.path("data", "mp02", fname)
    
    if(!file.exists(fname)){
        HISTORICAL_YEARS <- seq(start_year, 2018)
        
        HISTORICAL_DATA <- map(HISTORICAL_YEARS, function(yy){
            historical_url <- glue("https://www.census.gov/construction/bps/txt/tb3u{yy}.txt")
                
            LINES <- readLines(historical_url)[-c(1:11)]

            CBSA_LINES <- str_detect(LINES, "^[[:digit:]]")
            CBSA <- as.integer(str_sub(LINES[CBSA_LINES], 5, 10))

            PERMIT_LINES <- str_detect(str_sub(LINES, 48, 53), "[[:digit:]]")
            PERMITS <- as.integer(str_sub(LINES[PERMIT_LINES], 48, 53))
            
            data_frame(CBSA = CBSA,
                       new_housing_units_permitted = PERMITS, 
                       year = yy)
        }) |> bind_rows()
        
        CURRENT_YEARS <- seq(2019, end_year)
        
        CURRENT_DATA <- map(CURRENT_YEARS, function(yy){
            current_url <- glue("https://www.census.gov/construction/bps/xls/msaannual_{yy}99.xls")
            
            temp <- tempfile()
            
            download.file(current_url, destfile = temp, mode="wb")
            
            fallback <- function(.f1, .f2){
                function(...){
                    tryCatch(.f1(...), 
                             error=function(e) .f2(...))
                }
            }
            
            reader <- fallback(read_xlsx, read_xls)
            
            reader(temp, skip=5) |>
                na.omit() |>
                select(CBSA, Total) |>
                mutate(year = yy) |>
                rename(new_housing_units_permitted = Total)
        }) |> bind_rows()
        
        ALL_DATA <- rbind(HISTORICAL_DATA, CURRENT_DATA)
        
        write_csv(ALL_DATA, fname)
        
    }
    
    read_csv(fname, show_col_types=FALSE)
}

PERMITS <- get_building_permits()


ensure_package(httr2)
ensure_package(rvest)
get_bls_industry_codes <- function(){
    fname <- fname <- file.path("data", "mp02", "bls_industry_codes.csv")
    
    if(!file.exists(fname)){
    
        resp <- request("https://www.bls.gov") |> 
            req_url_path("cew", "classifications", "industry", "industry-titles.htm") |>
            req_headers(`User-Agent` = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:143.0) Gecko/20100101 Firefox/143.0") |> 
            req_error(is_error = \(resp) FALSE) |>
            req_perform()
        
        resp_check_status(resp)
        
        naics_table <- resp_body_html(resp) |>
            html_element("#naics_titles") |> 
            html_table() |>
            mutate(title = str_trim(str_remove(str_remove(`Industry Title`, Code), "NAICS"))) |>
            select(-`Industry Title`) |>
            mutate(depth = if_else(nchar(Code) <= 5, nchar(Code) - 1, NA)) |>
            filter(!is.na(depth))
        
        naics_table <- naics_table |> 
            filter(depth == 4) |> 
            rename(level4_title=title) |> 
            mutate(level1_code = str_sub(Code, end=2), 
                   level2_code = str_sub(Code, end=3), 
                   level3_code = str_sub(Code, end=4)) |>
            left_join(naics_table, join_by(level1_code == Code)) |>
            rename(level1_title=title) |>
            left_join(naics_table, join_by(level2_code == Code)) |>
            rename(level2_title=title) |>
            left_join(naics_table, join_by(level3_code == Code)) |>
            rename(level3_title=title) |>
            select(-starts_with("depth")) |>
            rename(level4_code = Code) |>
            select(level1_title, level2_title, level3_title, level4_title, 
                   level1_code,  level2_code,  level3_code,  level4_code)
    
        write_csv(naics_table, fname)
    }
    
    read_csv(fname, show_col_types=FALSE)
    
}

INDUSTRY_CODES <- get_bls_industry_codes()


ensure_package(httr2)
ensure_package(rvest)
get_bls_qcew_annual_averages <- function(start_year=2009, end_year=2023){
    fname <- glue("bls_qcew_{start_year}_{end_year}.csv.gz")
    fname <- file.path("data", "mp02", fname)
    
    YEARS <- seq(start_year, end_year)
    YEARS <- YEARS[YEARS != 2020] # Drop Covid year to match ACS
    
    if(!file.exists(fname)){
        ALL_DATA <- map(YEARS, .progress=TRUE, possibly(function(yy){
            fname_inner <- file.path("data", "mp02", glue("{yy}_qcew_annual_singlefile.zip"))
            
            if(!file.exists(fname_inner)){
                request("https://www.bls.gov") |> 
                    req_url_path("cew", "data", "files", yy, "csv",
                                 glue("{yy}_annual_singlefile.zip")) |>
                    req_headers(`User-Agent` = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:143.0) Gecko/20100101 Firefox/143.0") |> 
                    req_retry(max_tries=5) |>
                    req_perform(fname_inner)
            }
            
            if(file.info(fname_inner)$size < 755e5){
                warning(sQuote(fname_inner), "appears corrupted. Please delete and retry this step.")
            }
            
            read_csv(fname_inner, 
                     show_col_types=FALSE) |> 
                mutate(YEAR = yy) |>
                select(area_fips, 
                       industry_code, 
                       annual_avg_emplvl, 
                       total_annual_wages, 
                       YEAR) |>
                filter(nchar(industry_code) <= 5, 
                       str_starts(area_fips, "C")) |>
                filter(str_detect(industry_code, "-", negate=TRUE)) |>
                mutate(FIPS = area_fips, 
                       INDUSTRY = as.integer(industry_code), 
                       EMPLOYMENT = as.integer(annual_avg_emplvl), 
                       TOTAL_WAGES = total_annual_wages) |>
                select(-area_fips, 
                       -industry_code, 
                       -annual_avg_emplvl, 
                       -total_annual_wages) |>
                # 10 is a special value: "all industries" , so omit
                filter(INDUSTRY != 10) |> 
                mutate(AVG_WAGE = TOTAL_WAGES / EMPLOYMENT)
        })) |> bind_rows()
        
        write_csv(ALL_DATA, fname)
    }
    
    ALL_DATA <- read_csv(fname, show_col_types=FALSE)
    
    ALL_DATA_YEARS <- unique(ALL_DATA$YEAR)
    
    YEARS_DIFF <- setdiff(YEARS, ALL_DATA_YEARS)
    
    if(length(YEARS_DIFF) > 0){
        stop("Download failed for the following years: ", YEARS_DIFF, 
             ". Please delete intermediate files and try again.")
    }
    
    ALL_DATA
}

WAGES <- get_bls_qcew_annual_averages()
```

## Data Integration and Initial Exploration



### Extra Credit Opportunity #01: Relationship Diagram

The diagram below summarizes the structure of the datasets used in this project and the relationships among them.

![](images/diagram2.png){width="90%" fig-align="center"}

Each dataset in this project represents a distinct source of information related to housing affordability, and the diagram above shows the logical connections among them.

- **ACS Tables — INCOME, RENT, POPULATION, and HOUSEHOLDS:**  
  These datasets share the geographic identifier `GEOID` and the variable `year`.  
  These common keys allow one-to-one joins, aligning indicators such as median household income, monthly rent, population size, and number of households for each metropolitan area and each year.

- **PERMITS (Building Permits Survey):**  
  Uses the `CBSA` code to identify the same metropolitan areas.  
  While `CBSA` and `GEOID` are not identical, they represent equivalent regional boundaries and can be cross-referenced to connect new housing construction data with ACS demographic measures.

- **WAGES (Bureau of Labor Statistics):**  
  Uses the `FIPS` code to identify regions and includes variables for total employment, total wages, and average annual wage by industry (`INDUSTRY`).  
  Each `INDUSTRY` code link has a detailed description in the **INDUSTRY_CODES** table.

- **INDUSTRY_CODES (Lookup Table):**  
  Provides hierarchical industry classification labels that map the numeric codes in the WAGES dataset to descriptive names.

Put together, all these relationships show how multiple data sources with different identifiers (`GEOID`, `CBSA`, `FIPS`) and time references (`year`) can be integrated.  
Although the data are not fully normalized—some relationships, we have enough to study how income, rent, housing supply, and wage dynamics interact across U.S. metropolitan areas over time.

### Multi-Table Questions

**1.Which CBSA (by name) permitted the largest number of new housing units in the decade from 2010 to 2019 (inclusive)?**

```{r}
library(dplyr)
library(stringr)
format_titles <- function(df) {
  colnames(df) <- str_replace_all(colnames(df), "_", " ") |> str_to_title()
  df
}

largest_cbsa <- PERMITS |> 
  filter(year >= 2010 & year <= 2019) |> 
  group_by(CBSA) %>%
  summarize(total_permits = sum(new_housing_units_permitted, na.rm = TRUE)) |> 
  arrange(desc(total_permits)) |> 
  left_join(HOUSEHOLDS, by = c("CBSA" = "GEOID")) |> 
  slice(1) |> 
  select(NAME, total_permits)

highlight <- function(x) {
  paste0('<span style="color:#0000ff;"><b>', x, '</b></span>')
}
```

The CBSA that permitted the largest number of new housing units in the decade from 2010 to 2019 (inclusive) is `r highlight(largest_cbsa$NAME)`, which permitted `r highlight(scales::comma(largest_cbsa$total_permits))` new housing units.

**2.In what year did Albuquerque, NM (CBSA Number 10740) permit the most new housing units?**

```{r}
  housing_permits<- PERMITS |> 
    filter(CBSA == 10740) |> 
    arrange(desc(new_housing_units_permitted)) |> 
    slice(1) |> 
    select(year, new_housing_units_permitted)
```
Abuquerque, NM (CBSA Number 10740) issued the most new housing units in the year of `r highlight(housing_permits$year)`, for a total of `r highlight(housing_permits$new_housing_units_permitted)`.

**3.Which state (not CBSA) had the highest average individual income in 2015? To answer this question, you will need to first compute the total income per CBSA by multiplying the average household income by the number of households, and then sum total income and total population across all CBSAs in a state. With these numbers, you can answer this question.**

```{r}
  library(stringr)
  library(DT)
  
  highest_indiv_income_2015 <- INCOME |> 
    filter(year == 2015) |> 
    mutate(state = str_extract(NAME, "., ([A-Z]{2})", group = 1)) |> 
    left_join(HOUSEHOLDS |>  filter(year == 2015) |>  select(GEOID, households), 
              by = "GEOID") |> 
    mutate(total_income = household_income * households) |> 
    group_by(state) |> 
    summarize(total_income = sum(total_income, na.rm = TRUE),
              total_households = sum(households, na.rm = TRUE)) |> 
    mutate(avg_individual_income = total_income / total_households) |> 
    arrange(desc(avg_individual_income)) |> 
    slice(1) |> 
    select(state, avg_individual_income)
  
```
The state with the highest average individual income in 2015 was `r highlight(highest_indiv_income_2015$state)`, with an average individual income of `r highlight(round(highest_indiv_income_2015$avg_individual_income, 2))`.

**4.Data scientists and business analysts are recorded under NAICS code 5182. What is the last year in which the NYC CBSA had the most data scientists in the country? In recent, the San Francisco CBSA has had the most data scientists.**


```{r}

library(dplyr)

# Filter WAGES data for data scientists (NAICS 5182) first
wages_filtered <- WAGES |>
  filter(INDUSTRY == 5182) |>
  mutate(std_cbsa = paste0(FIPS, "0"))

# Filter POPULATION data and prepare for join
population_filtered <- POPULATION |>
  mutate(std_cbsa = paste0("C", GEOID))

# Join the datasets on std_cbsa and year
data_scientists <- wages_filtered |>
  inner_join(
    population_filtered |> select(std_cbsa, NAME, year),
    by = c("std_cbsa" = "std_cbsa", "YEAR" = "year")
  )

# Group by year and CBSA to find which had the most data scientists
ds_by_year <- data_scientists |>
  group_by(YEAR, NAME) |>
  summarise(total_employment = sum(EMPLOYMENT, na.rm = TRUE), .groups = "drop") |>
  group_by(YEAR) |>
  slice_max(total_employment, n = 1) |>
  ungroup() |>
  arrange(desc(YEAR))

# Find the last year NYC had the most data scientists
last_nyc_year <- ds_by_year |>
  filter(grepl("New York", NAME, ignore.case = TRUE)) |>
  pull(YEAR) |>
  max()


# Filter to show only NYC area rows
nyc_only <- ds_by_year |>
  filter(grepl("New York", NAME, ignore.case = TRUE)) |> 
  format_titles() |> 
  datatable(options = list(searching = FALSE, info = FALSE)) |> 
  formatRound(c("Total Employment"))   
nyc_only
```

The last year in which the NYC CBSA had the most data scientists in the country was `r highlight(last_nyc_year)`.

**5. What fraction of total wages in the NYC CBSA was earned by people employed in the finance and insurance industries (NAICS code 52)? In what year did this fraction peak?**

```{r fraction_finance_insurance_nyc}
#  Step 1: Filter WAGES data before joining
wages_filtered <- WAGES |>
  mutate(std_cbsa = paste0(FIPS, "0"))

# Step 2: Filter POPULATION data and prepare for join
population_filtered <- POPULATION |>
  mutate(std_cbsa = paste0("C", GEOID)) |>
  filter(grepl("New York", NAME, ignore.case = TRUE))

# Step 3: Join to get NYC data only
nyc_wages <- wages_filtered |>
  inner_join(
    population_filtered |> select(std_cbsa, NAME, year),
    by = c("std_cbsa" = "std_cbsa", "YEAR" = "year")
  )

# Step 4: Calculate total wages by year for NYC
total_wages_by_year <- nyc_wages |>
  group_by(YEAR) |>
  summarise(total_wages = sum(TOTAL_WAGES, na.rm = TRUE), .groups = "drop")

# Step 5: Calculate finance and insurance (NAICS 52) wages by year for NYC
finance_wages_by_year <- nyc_wages |>
  filter(INDUSTRY == 52) |>
  group_by(YEAR) |>
  summarise(finance_wages = sum(TOTAL_WAGES, na.rm = TRUE), .groups = "drop")

# Step 6: Join and calculate the fraction
finance_fraction <- total_wages_by_year |>
  inner_join(finance_wages_by_year, by = "YEAR") |>
  mutate(fraction = finance_wages / total_wages) |>
  arrange(YEAR)


# Find the year with the peak fraction
peak_year <- finance_fraction |>
  slice_max(fraction, n = 1)

```

The fraction of total wages in the NYC CBSA earned by people employed in the finance and insurance industries The fraction of total wages in the NYC CBSA earned by people employed in the finance and insurance industries peaked in the year `r highlight(peak_year$YEAR[[1]])`, with a fraction of `r highlight(round(peak_year$fraction[[1]] * 100, 2))`%.

### Initial Visualizations

**1. The relationship between monthly rent and average household income per CBSA in 2009 using ggplot**
```{r monthly_rent_vs_income_2009}
library(ggpmisc)
library(ggplot2)
income_rent_2009 <- INCOME |> 
  filter(year == 2009) |> 
  inner_join(RENT %>% filter(year == 2009), by = c("GEOID", "year"))
ggplot(income_rent_2009, aes(x = household_income, y = monthly_rent)) +
  geom_point(color = "blue", alpha = 0.6) +
  stat_poly_line(se = FALSE, 
                 color = "red") +
  stat_poly_eq()+
  labs(title = "Monthly Rent vs. Average Household Income (2009)",
       x = "Average Household Income",
       y = "Monthly Rent") +
  theme_bw()
```
There's a clear positive correlation between average household income and monthly rent in 2009. As household income increases, the monthly rent tends to increase as well. The fitted regression line indicates that higher-income households generally pay higher rents, suggesting that rent prices are influenced by the income levels of residents in different CBSAs.

The coefficient of determination (R²) of 0.58 indicates that approximately 58% of the variation in monthly rent can be explained by average household income. This translates to a correlation coefficient of r ≈ 0.76, suggesting a strong positive relationship.



**2. The relationship between total employment and total employment in the health care and social services sector (NAICS 62) across different CBSAs. Design your visualization so that it is possible to see the evolution of this relationship over time.**

```{r total_vs_healthcare_employment}
library(dplyr)
library(ggplot2)

#  Step 1: Filter WAGES data for healthcare (NAICS 62) before joining
healthcare_wages <- WAGES |>
  filter(INDUSTRY == 62) |>
  mutate(std_cbsa = paste0(FIPS, "0")) |>
  group_by(std_cbsa, YEAR) |>
  summarise(healthcare_employment = sum(EMPLOYMENT, na.rm = TRUE), .groups = "drop")

# Step 2: Calculate total employment by CBSA and year
total_employment <- WAGES |>
  mutate(std_cbsa = paste0(FIPS, "0")) |>
  group_by(std_cbsa, YEAR) |>
  summarise(total_employment = sum(EMPLOYMENT, na.rm = TRUE), .groups = "drop")

# Step 3: Join healthcare and total employment data
employment_data <- total_employment |>
  inner_join(healthcare_wages, by = c("std_cbsa", "YEAR")) |>
  inner_join(
    POPULATION |> mutate(std_cbsa = paste0("C", GEOID)) |> select(std_cbsa, NAME, year),
    by = c("std_cbsa" = "std_cbsa", "YEAR" = "year")
  ) |>
  mutate(healthcare_share = healthcare_employment / total_employment)

employment_data_clean <- employment_data %>%
  filter(total_employment > 0,
         healthcare_employment > 0,
         is.finite(total_employment),
         is.finite(healthcare_employment))


ggplot(employment_data_clean, aes(x = total_employment, y = healthcare_employment, color = YEAR)) +
  geom_point(alpha = 0.6, size = 2) +
  geom_smooth(method = "lm", formula = y ~ x, 
              se = FALSE, alpha = 0.3, na.rm = TRUE) +
  facet_wrap(~YEAR, scales = "free") +
  scale_x_log10(
  breaks = scales::trans_breaks("log10", function(x) 10^x, n = 5),
  labels = scales::label_number(scale_cut = scales::cut_short_scale())
) +
scale_y_log10(
  breaks = scales::trans_breaks("log10", function(x) 10^x, n = 5),
  labels = scales::label_number(scale_cut = scales::cut_short_scale())
)+

  labs(
    title = "Relationship Between Total Employment and Healthcare Employment by CBSA",
    subtitle = "Evolution over time across different years",
    x = "Total Employment (log scale)",
    y = "Healthcare & Social Services Employment (log scale)",
    color = "Year"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    legend.position = "bottom"
  )

```


**3. The evolution of average household size over time. Use different lines to represent different CBSAs. For each plot, make sure your final visualization is publication-ready and equipped with, at a minimum.**

- Proper x and y-axis axis labels
- A meaningful title
- Proper units for axis ticks (if appropriate)
- Proper legend titles (if appropriate)
- Proper font sizes so that all text is legible.

```{r avg_household_size_evolution, warning=FALSE, message=FALSE}
library(dplyr)
library(ggplot2)
library(scales)

# --- Build CBSA–year totals from WAGES ---
health_emp <- WAGES %>%
  group_by(YEAR, FIPS) %>%
  summarise(
    total_emp  = sum(EMPLOYMENT, na.rm = TRUE),
    health_emp = sum(EMPLOYMENT[INDUSTRY == 62], na.rm = TRUE),
    .groups = "drop"
  ) %>%
  filter(total_emp > 0) %>%                      # keep valid rows
  mutate(std_cbsa = paste0(FIPS, "0"))           # to match Census IDs

# (optional) add CBSA names for nicer plots/tooltips/filters
cbsa_names <- POPULATION %>%
  mutate(std_cbsa = paste0("C", GEOID)) %>%
  distinct(std_cbsa, NAME)

health_emp <- health_emp %>% left_join(cbsa_names, by = "std_cbsa")

ggplot(health_emp, aes(x = total_emp, y = health_emp)) +
  # Reduce overplotting with transparency and smaller points
  geom_point(alpha = 0.35, size = 2, color = "blue") +
  # Add regression line in black
  geom_smooth(method = "lm", color = "black", se = FALSE, linewidth = 0.8) +
  scale_x_log10(labels = comma) +
  scale_y_log10(labels = comma) +
  facet_wrap(~ YEAR, ncol = 4) +
  labs(
    title = "Health Care & Social Services vs Total Employment across CBSAs",
    subtitle = "Each panel is a year; log scales show the relationship across city sizes",
    x = "Total employment (log scale)",
    y = "Health care & social services employment (log scale)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(size = 11, hjust = 0.5),
    axis.title = element_text(size = 10),
    axis.text = element_text(size = 9),
    strip.text = element_text(size = 10, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.text.y = element_text(angle = 45, hjust = 1)
  )

```
## Building Indices of Housing Affordability and Housing Stock Growth

We will begin by constructing an initial metric of rent affordability by combining our INCOME, RENT, and POPULATION tables from above. Using a suitable join, we merge these three into a single table which can be used to perform the following task.

### Rent Burden

**1. Standardization:** Define a baseline value around which your metric is centered.  
Some possible baseline structures may include:

- Setting 0, 50, or 100 to the long-term national average  
- Setting 0, 50, or 100 to the national average in the first year of your study  
- Setting 0 to the lowest value and 100 to the highest value in the study.

**2. Scaling and Transformation**: Standardize your metric to increase interpretability. Some standardizations may include:

- Setting 0 to the lowest value, 100 to the highest value, and linearly scaling in between
- Dividing by the standard deviation so that values can be interpreted as “standard deviations above average”
- Dividing by the baseline value so that values can be interpreted as “
 times baseline”


```{r housing_affordability_index}
# Load required libraries
library(dplyr)

# Step 1: Join INCOME and RENT tables
rent_burden_raw <- INCOME |>
  inner_join(
    RENT,
    by = c("GEOID" = "GEOID", "year" = "year"),
    suffix = c("_income", "_rent")
  ) |>
  select(GEOID, NAME_income, year, household_income, monthly_rent) |>
  rename(NAME = NAME_income)

# Step 2: Calculate basic rent-to-income ratio
# Annualize monthly rent and compute ratio
rent_burden_raw <- rent_burden_raw |>
  mutate(
    annual_rent = monthly_rent * 12,
    raw_rent_to_income = annual_rent / household_income
  )

# Step 3: Calculate national baseline (long-term average across all years and CBSAs)
national_baseline <- rent_burden_raw |>
  summarise(mean_rent_to_income = mean(raw_rent_to_income, na.rm = TRUE)) |>
  pull(mean_rent_to_income)

cat("National baseline rent-to-income ratio:", round(national_baseline, 4), "\n\n")

# Step 4: Create standardized rent burden index
rent_burden_data <- rent_burden_raw |>
  mutate(
    # Standardized index (50 = national average)
    rent_burden_index = (raw_rent_to_income / national_baseline) * 50,
    
    # Classification for interpretation
    burden_level = case_when(
      rent_burden_index < 30 ~ "Very Low",
      rent_burden_index < 40 ~ "Low",
      rent_burden_index < 50 ~ "Below Average",
      rent_burden_index < 60 ~ "Above Average",
      rent_burden_index < 70 ~ "High",
      TRUE ~ "Very High"
    )
  ) |>
  select(GEOID, NAME, year, household_income, monthly_rent, 
         annual_rent, raw_rent_to_income, rent_burden_index, burden_level) |>
  arrange(year, rent_burden_index)

# Display summary statistics
cat("Rent Burden Index Summary Statistics:\n")
cat("=====================================\n")
cat("Min:", round(min(rent_burden_data$rent_burden_index, na.rm = TRUE), 2), "\n")
cat("Q1:", round(quantile(rent_burden_data$rent_burden_index, 0.25, na.rm = TRUE), 2), "\n")
cat("Median:", round(median(rent_burden_data$rent_burden_index, na.rm = TRUE), 2), "\n")
cat("Mean:", round(mean(rent_burden_data$rent_burden_index, na.rm = TRUE), 2), "\n")
cat("Q3:", round(quantile(rent_burden_data$rent_burden_index, 0.75, na.rm = TRUE), 2), "\n")
cat("Max:", round(max(rent_burden_data$rent_burden_index, na.rm = TRUE), 2), "\n\n")

# Show examples of high and low burden CBSAs
cat("Top 10 Highest Rent Burden (most recent year):\n")
print(
  rent_burden_data |>
    filter(year == max(year)) |>
    slice_max(rent_burden_index, n = 10) |>
    select(NAME, year, household_income, monthly_rent, rent_burden_index, burden_level) |>
    format_titles() |> 
    datatable(options = list(searching = FALSE, info = FALSE)) |> 
    formatRound(c("Household Income", "Monthly Rent", "Rent Burden Index", "Burden Level"))
)

cat("\n\nTop 10 Lowest Rent Burden (most recent year):\n")
print(
  rent_burden_data |>
    filter(year == max(year)) |>
    slice_min(rent_burden_index, n = 10) |>
    select(NAME, year, household_income, monthly_rent, rent_burden_index, burden_level) |> 
    format_titles() |> 
    datatable(options = list(searching = FALSE, info = FALSE)) |> 
    formatRound(c("Household Income", "Monthly Rent", "Rent Burden Index", "Burden Level"))
)
```

### Housing Growth

Join together the POPULATION and PERMITS tables. Using this data, construct a suitable measure of housing growth: that is, how many new housing units are permitted in a CBSA, relative to both the current number of residents and the overall population growth of that CBSA. Because this metric takes into account growth patterns, it should depend on a fixed lookback-window of 5 years used to estimate population growth.

Before constructing your metric, use dplyr functionality to calculate population growth within each CBSA over a rolling 5 year window. Since your data begins in 2009, your five-year estimates of population growth will start in 2014. The lag function may be useful here.

Construct your metric in two parts:

An ‘instantaneous’ measure of housing growth that depends on the absolute population of a CBSA and the number of new housing units permitted that year.
A ‘rate-based’ measure of housing growth that compares the number of housing permits to the population growth over a 5 year lookback window.
For each of these, suitably standardize and baseline your metric. You may choose to use housing permits and population on their own, construct ratios, or other transformations necessary to construct suitable metrics.

Once you have developed the two individual metrics, construct two tables identifying the CBSAs that score particularly high or low on each metric.

Finally, develop a composite score that combines these two metrics. This may be a sum, weighted sum, maximum, minimum, or any other combination function you feel works best.2 As before, identify CBSAs that do particularly well and particularly poorly on your metric.

Because homebuilding is a slow process, it may be worth aggregating over years. You can use the cummean-family of functions from dplyr to compute cumulative statistics or the roll_* functions from the RcppRoll package to get a rolling estimate, e.g., a rolling 5-year average.


```{r housing_growth, warning=FALSE, message=FALSE}
# Load required libraries
library(dplyr)
library(RcppRoll)

# Step 1: Join POPULATION and PERMITS tables
# Note: PERMITS uses CBSA, POPULATION uses GEOID (which are the same values)
housing_data <- POPULATION |>
  select(GEOID, NAME, year, population) |>
  inner_join(
    PERMITS |> rename(GEOID = CBSA),
    by = c("GEOID" = "GEOID", "year" = "year")
  ) |>
  arrange(GEOID, year)

# Step 2: Calculate 5-year population growth within each CBSA
housing_data <- housing_data |>
  group_by(GEOID) |>
  mutate(
    # Population 5 years ago
    population_5yr_ago = lag(population, n = 5),
    
    # 5-year population growth
    population_growth_5yr = population - population_5yr_ago,
    
    # Population growth rate (%)
    population_growth_rate_5yr = ((population - population_5yr_ago) / population_5yr_ago) * 100,
    
    # Year indicator for filtering (5-year window starts at 2014)
    year_indicator = if_else(year >= 2014, 1, 0)
  ) |>
  ungroup()

cat("Population growth calculated. Data starts reliably from 2014 onwards.\n\n")

# Step 3: Calculate baseline statistics for standardization
# Calculate national median values for standardization
national_permits_median <- housing_data |>
  summarise(median_permits = median(new_housing_units_permitted, na.rm = TRUE)) |>
  pull(median_permits)

national_pop_median <- housing_data |>
  summarise(median_pop = median(population, na.rm = TRUE)) |>
  pull(median_pop)

national_growth_median <- housing_data |>
  filter(year_indicator == 1) |>
  summarise(median_growth = median(population_growth_5yr, na.rm = TRUE)) |>
  pull(median_growth)


# Step 4: Construct Metric 1 - Instantaneous Housing Growth
# Housing units per capita (permits relative to current population)
# Standardized: (permits / population) / (national_permits / national_pop) * 50
housing_data <- housing_data |>
  mutate(
    # Raw ratio: permits per 1000 residents
    permits_per_1000_pop = (new_housing_units_permitted / population) * 1000,
    
    # National average permits per 1000
    national_permits_per_1000 = (national_permits_median / national_pop_median) * 1000,
    
    # Standardized instantaneous metric (50 = national average)
    instantaneous_metric = (permits_per_1000_pop / national_permits_per_1000) * 50
  )

# Step 5: Construct Metric 2 - Rate-Based Housing Growth
# Compare housing permits to population growth
# Only calculate for years where we have 5-year growth data
housing_data <- housing_data |>
  mutate(
    # Permits relative to 5-year population growth
    # If population declining, use minimum population for denominator
    population_growth_5yr_adj = pmax(population_growth_5yr, 1),
    
    permits_to_growth_ratio = new_housing_units_permitted / population_growth_5yr_adj,
    
    # Standardize using national median
    rate_based_metric = if_else(
      year_indicator == 1,
      (permits_to_growth_ratio / median(permits_to_growth_ratio, na.rm = TRUE)) * 50,
      NA_real_
    )
  )

# Step 6: Construct Composite Score
# Composite = average of both metrics (equal weighting)
# Only calculate for years with complete data (2014+)
housing_data <- housing_data |>
  mutate(
    composite_score = if_else(
      year_indicator == 1,
      (instantaneous_metric + rate_based_metric) / 2,
      NA_real_
    )
  )

# Step 7: Apply rolling average (3-year) for stability
housing_data <- housing_data |>
  group_by(GEOID) |>
  mutate(
    composite_score_rolling = roll_mean(composite_score, n = 3, na.rm = TRUE, fill = NA)
  ) |>
  ungroup()


# Step 8: Identify top and bottom CBSAs on Instantaneous Metric (most recent year)
recent_year <- max(housing_data$year[housing_data$year_indicator == 1])

cat(paste0(rep("=", 83), collapse = ""), "\n")
cat("INSTANTANEOUS METRIC - Top 10 (Permits per Population)\n")
cat(paste0(rep("=", 83), collapse = ""), "\n")
print(
  housing_data |>
    filter(year == recent_year) |>
    slice_max(instantaneous_metric, n = 10) |>
    select(NAME, year, population, new_housing_units_permitted, 
           permits_per_1000_pop, instantaneous_metric) |>
    arrange(desc(instantaneous_metric)) |> 
    format_titles() |> 
    datatable(options = list(searching = FALSE, info = FALSE)) |> 
    formatRound(c("Population", "New Housing Units Permitted", "Permits Per 1000 Pop", "Instantaneous Metric"))
)

print(
  housing_data |>
    filter(year == recent_year) |>
    slice_min(instantaneous_metric, n = 10) |>
    select(NAME, year, population, new_housing_units_permitted, 
           permits_per_1000_pop, instantaneous_metric) |>
    arrange(instantaneous_metric) |>
    format_titles() |> 
    datatable(options = list(searching = FALSE, info = FALSE)) |> 
    formatRound(c("Population", "New Housing Units Permitted", "Permits Per 1000 Pop", "Instantaneous Metric"))
)

# Step 9: Identify top and bottom CBSAs on Rate-Based Metric
print(
  housing_data |>
    filter(year == recent_year, !is.na(rate_based_metric)) |>
    slice_max(rate_based_metric, n = 10) |>
    select(NAME, year, population_growth_5yr, new_housing_units_permitted, 
           permits_to_growth_ratio, rate_based_metric) |>
    arrange(desc(rate_based_metric)) |> 
    format_titles() |> 
    datatable(options = list(searching = FALSE, info = FALSE)) |> 
    formatRound(c("Population Growth 5yr", "New Housing Units Permitted", "Permits To Growth Ratio", "Rate Based Metric"))

)

cat("\n", paste0(rep("=", 83), collapse = ""), "\n", sep = "")
cat("RATE-BASED METRIC - Bottom 10\n")
cat(paste0(rep("=", 83), collapse = ""), "\n")
print(
  housing_data |>
    filter(year == recent_year, !is.na(rate_based_metric)) |>
    slice_min(rate_based_metric, n = 10) |>
    select(NAME, year, population_growth_5yr, new_housing_units_permitted, 
           permits_to_growth_ratio, rate_based_metric) |>
    arrange(rate_based_metric) |>
    format_titles() |> 
    datatable(options = list(searching = FALSE, info = FALSE)) |> 
    formatRound(c("Population Growth 5yr", "New Housing Units Permitted", "Permits To Growth Ratio", "Rate Based Metric"))
)

# Step 10: Identify top and bottom CBSAs on Composite Score
cat("\n", paste0(rep("=", 83), collapse = ""), "\n", sep = "")
cat("COMPOSITE SCORE - Top 10 (Best for Housing Growth)\n")
cat(paste0(rep("=", 83), collapse = ""), "\n")
print(
  housing_data |>
    filter(year == recent_year, !is.na(composite_score)) |>
    slice_max(composite_score_rolling, n = 10, na_rm = TRUE) |>
    select(NAME, year, instantaneous_metric, rate_based_metric, 
           composite_score, composite_score_rolling) |>
    arrange(desc(composite_score_rolling)) |> 
    format_titles() |> 
    datatable(options = list(pageLength = 10, searching = FALSE, info = FALSE)) |> 
    formatRound(c("Instantaneous Metric", "Rate Based Metric", "Composite Score", "Composite Score Rolling"))
)

cat("\n", paste0(rep("=", 83), collapse = ""), "\n", sep = "")
cat("COMPOSITE SCORE - Bottom 10 (Worst for Housing Growth)\n")
cat(paste0(rep("=", 83), collapse = ""), "\n")
print(
  housing_data |>
    filter(year == recent_year, !is.na(composite_score)) |>
    slice_min(composite_score_rolling, n = 10, na_rm = TRUE) |>
    select(NAME, year, instantaneous_metric, rate_based_metric, 
           composite_score, composite_score_rolling) |>
    format_titles() |>
    datatable(options = list(searching = FALSE, info = FALSE)) |>
    formatRound(c("Instantaneous Metric", "Rate Based Metric", "Composite Score", "Composite Score Rolling"))
)

```
### Visiualization

Create (at least) two visualizations to investigate the relationships between your Rent Burden and Housing Growth metrics. Using these plots, identify the most “YIMBY” CBSAs as ones which:

- had relatively high rent burden in the early part of the study period;
- have had a decrease in rent burden over the study period;
- have had population growth over the study period; and
- have had above-average housing growth during the study period.

A CBSA exhibiting all of these qualities is (arguably) an example of YIMBY success and is not a city in decline, as would be indicated by falling population resulting in lower rents.

```{r yimby_success_analysis, warning=FALSE, message=FALSE}
# Load required libraries
library(dplyr)
library(ggplot2)
library(gghighlight)

# Step 1: Merge rent burden and housing growth data
# First, prepare rent burden data by year
rent_burden_by_year <- rent_burden_data |>
  group_by(GEOID, NAME, year) |>
  summarise(
    avg_rent_burden_index = mean(rent_burden_index, na.rm = TRUE),
    .groups = "drop"
  )

# Prepare housing growth data
housing_growth_by_year <- housing_data |>
  select(GEOID, NAME, year, population, composite_score, 
         composite_score_rolling, instantaneous_metric, rate_based_metric) |>
  distinct()

# Merge the two datasets
yimby_data <- rent_burden_by_year |>
  inner_join(
    housing_growth_by_year,
    by = c("GEOID" = "GEOID", "NAME" = "NAME", "year" = "year")
  ) |>
  arrange(GEOID, year)

# Step 2: Calculate YIMBY criteria for each CBSA
yimby_criteria <- yimby_data |>
  group_by(GEOID, NAME) |>
  summarise(
    # Criterion 1: High rent burden in early period (2009-2013 average)
    early_rent_burden = mean(avg_rent_burden_index[year < 2014], na.rm = TRUE),
    
    # Criterion 2: Decrease in rent burden over study period
    rent_burden_change = mean(avg_rent_burden_index[year >= 2020], na.rm = TRUE) - 
      mean(avg_rent_burden_index[year < 2014], na.rm = TRUE),
    
    # Criterion 3: Population growth over study period
    pop_start = population[year == min(year)],
    pop_end = population[year == max(year)],
    population_growth = pop_end - pop_start,
    population_growth_pct = ((pop_end - pop_start) / pop_start) * 100,
    
    # Criterion 4: Above-average housing growth
    avg_housing_growth = mean(composite_score_rolling, na.rm = TRUE),
    
    .groups = "drop"
  ) |>
  mutate(
    # Score each criterion (1 = meets criterion, 0 = does not)
    criterion_1_high_burden = ifelse(early_rent_burden > 50, 1, 0),
    criterion_2_decreased_burden = ifelse(rent_burden_change < 0, 1, 0),
    criterion_3_pop_growth = ifelse(population_growth > 0, 1, 0),
    criterion_4_housing_growth = ifelse(avg_housing_growth > 50, 1, 0),
    
    # YIMBY score (0-4, higher is better)
    yimby_score = criterion_1_high_burden + criterion_2_decreased_burden + 
      criterion_3_pop_growth + criterion_4_housing_growth,
    
    # Identify perfect YIMBY CBSAs (score = 4)
    is_yimby = ifelse(yimby_score == 4, TRUE, FALSE)
  ) |>
  arrange(desc(yimby_score))

# Display YIMBY results
cat("YIMBY Success Analysis\n")
cat(paste0(rep("=", 83), collapse = ""), "\n")
cat("\nCBSAs Meeting All 4 YIMBY Criteria (Perfect YIMBY Success):\n")
cat(paste0(rep("-", 83), collapse = ""), "\n")
perfect_yimby <- yimby_criteria |> filter(yimby_score == 4)
if (nrow(perfect_yimby) > 0) {
  print(perfect_yimby |> 
          select(NAME, yimby_score, early_rent_burden, rent_burden_change, 
                 population_growth_pct, avg_housing_growth))
} else {
  cat("No CBSAs meet all 4 criteria.\n")
}

cat("\n\nTop 15 CBSAs by YIMBY Score:\n")
cat(paste0(rep("-", 83), collapse = ""), "\n")
print(yimby_criteria |> 
        head(15) |>
        select(NAME, yimby_score, early_rent_burden, rent_burden_change, 
               population_growth_pct, avg_housing_growth))

# Visualization 1: Scatter plot of Rent Burden vs Housing Growth
cat("\n\nCreating Visualization 1: Rent Burden vs Housing Growth\n")
viz1 <- ggplot(yimby_criteria, aes(x = avg_housing_growth, y = early_rent_burden,
                                   size = population_growth_pct,
                                   color = rent_burden_change)) +
  geom_point(alpha = 0.6) +
  gghighlight(
    is_yimby,
    use_direct_label = TRUE,
    label_key = NAME,
    unhighlighted_params = list(colour = alpha("gray70", 0.3), size = 2, alpha = 0.2)
  ) +
  scale_color_gradient2(
    low = "#2ecc71", mid = "#f39c12", high = "#e74c3c",
    name = "Rent Burden\nChange",
    midpoint = 0
  ) +
  labs(
    title = "YIMBY Success: Housing Growth vs Rent Burden",
    subtitle = "Highlighted CBSAs meet all 4 YIMBY criteria",
    x = "Average Housing Growth Score (higher = more building-friendly)",
    y = "Early Period Rent Burden Index (2009-2013)",
    size = "Population\nGrowth %",
    caption = "Point size: population growth | Color: change in rent burden (green=improvement, red=worsening)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 11),
    axis.title = element_text(size = 11, face = "bold"),
    legend.position = "right"
  )

print(viz1)

# Visualization 2: Multi-dimensional view with all 4 criteria
cat("\nCreating Visualization 2: All 4 YIMBY Criteria\n")
viz2 <- ggplot(yimby_criteria, aes(x = rent_burden_change, y = population_growth_pct)) +
  geom_point(aes(size = avg_housing_growth, color = early_rent_burden), alpha = 0.6) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray50", size = 0.5) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray50", size = 0.5) +
  gghighlight(
    is_yimby,
    use_direct_label = TRUE,
    label_key = NAME,
    unhighlighted_params = list(colour = alpha("gray70", 0.3), size = 2, alpha = 0.2)
  ) +
  scale_color_gradient(
    low = "#e74c3c", high = "#3498db",
    name = "Early Rent\nBurden Index"
  ) +
  labs(
    title = "YIMBY Success: Four Criteria Combined",
    subtitle = "Ideal quadrant: top-left (decreasing rent burden, growing population)",
    x = "Rent Burden Change (negative = improvement)",
    y = "Population Growth %",
    size = "Housing\nGrowth Score",
    caption = "Color: early rent burden | Size: housing growth score | Highlighted: perfect YIMBY matches"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 11),
    axis.title = element_text(size = 11, face = "bold"),
    legend.position = "right"
  )

print(viz2)
```
## Policy Brief

FEDERAL YIMBY HOUSING INITIATIVE
Policy Brief: Building Homes, Growing Economies

THE OPPORTUNITY
Housing affordability is crippling economic growth in America's largest metros. While some cities have successfully balanced housing supply with demand—keeping rents stable even as populations grew—others remain trapped in an affordability crisis. This brief proposes a federal grant program to help NIMBY cities adopt proven housing-friendly policies.

PROPOSED CONGRESSIONAL SPONSORS
Primary Sponsor: Representative from Austin, TX (or similar high-YIMBY success city)

Austin exemplifies YIMBY success: high early rent burden (65+ index), now declining, with 15%+ population growth and strong housing permits. This city proves the strategy works.

Co-Sponsor: Representative from New York, NY (or similar high-rent, low-build city)

NYC represents the cautionary tale: extremely high rent burden (75+ index), minimal improvement, despite population demands. Federal support could unlock local reform.


KEY METRICS: HOW WE MEASURE SUCCESS
Rent Burden Index

Tracks what percentage of income residents spend on housing, standardized so 50 = national average, >60 = affordability crisis
Shows which cities need intervention and whether policies are working

Housing Growth Score

Measures housing permits relative to population size AND population growth
Scores >50 mean cities are building enough homes; <40 means housing shortage
Identifies which cities are supply-constrained


COALITION BUILDING: WINNING LOCAL SUPPORT
Healthcare Workers

In NIMBY cities (NYC): Healthcare workers spend 35%+ of income on rent; YIMBY reform cuts this to 25%
Benefit: Better recruitment/retention, higher quality of life for essential workers
Union support: National Nurses United, SEIU Healthcare Workers

Construction & Building Trades

In YIMBY cities (Austin): 5,000+ new construction jobs from sustained housing growth
In NIMBY cities (NYC): Restricted zoning kills construction jobs; reform creates sustainable employment
Union support: Laborers' International Union, United Brotherhood of Carpenters


WHY THIS BILL SUCCEEDS
For YIMBY success cities like Austin: Federal grants reward their forward-thinking policies and accelerate proven models
For NIMBY-constrained cities like NYC: Grants incentivize zoning reform, directly addressing local affordability crises
For unions: Predictable housing growth = stable, long-term employment; rental affordability = workers keep more wages
For Republicans: Market-driven; uses carrots (grants) not mandates
For Democrats: Directly addresses affordability crisis; lifts working families

RECOMMENDED FEDERAL GRANT CRITERIA
Grant eligibility based on:

Rent Burden > 55 (cities in crisis that commit to reform)
Housing Growth Score <45 (restricted building that can improve)
Demonstrated zoning reform (cities must change local policy to receive funds)

Grants fund:

Technical assistance for zoning modernization
Infrastructure improvements in newly-zoned areas
Public-private partnerships for mixed-income housing


BOTTOM LINE
This is a bipartisan opportunity to unlock housing supply in constrained metros while rewarding cities already doing it right. Data proves the model works in Austin, Denver, and other YIMBY leaders. Federal investment scales success and brings relief to working families paying unsustainable rent.
