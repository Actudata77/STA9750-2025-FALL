---
title: "Mini Project 2: Making Backyards Affordable for All"
author: "Hyacinthe Sarr"
format:
  html:
    toc: true
    toc-title: "Contents"
    number-sections: true
    theme: materia
    code-fold: true
    code-summary: "Show code"
---

![](images/pic2.png){width="100%" fig-align="center"}
## Introduction









## Data Acquisition


```{r}
#| echo: true
#| message: false
#| warning: false
#| code-fold: true
#| code-summary: "Show technical details"

if(!dir.exists(file.path("data", "mp02"))){
    dir.create(file.path("data", "mp02"), showWarnings=FALSE, recursive=TRUE)
}

ensure_package <- function(pkg){
    pkg <- as.character(substitute(pkg))
    options(repos = c(CRAN = "https://cloud.r-project.org"))
    if(!require(pkg, character.only=TRUE, quietly=TRUE)) install.packages(pkg)
    stopifnot(require(pkg, character.only=TRUE, quietly=TRUE))
}

ensure_package(tidyverse)
ensure_package(glue)
ensure_package(readxl)
ensure_package(tidycensus)

get_acs_all_years <- function(variable, geography="cbsa",
                              start_year=2009, end_year=2023){
    fname <- glue("{variable}_{geography}_{start_year}_{end_year}.csv")
    fname <- file.path("data", "mp02", fname)
    
    if(!file.exists(fname)){
        YEARS <- seq(start_year, end_year)
        YEARS <- YEARS[YEARS != 2020] # Drop 2020 - No survey (covid)
        
        ALL_DATA <- map(YEARS, function(yy){
            tidycensus::get_acs(geography, variable, year=yy, survey="acs1") |>
                mutate(year=yy) |>
                select(-moe, -variable) |>
                rename(!!variable := estimate)
        }) |> bind_rows()
        
        write_csv(ALL_DATA, fname)
    }
    
    read_csv(fname, show_col_types=FALSE)
}

# Household income (12 month)
INCOME <- get_acs_all_years("B19013_001") |>
    rename(household_income = B19013_001)

# Monthly rent
RENT <- get_acs_all_years("B25064_001") |>
    rename(monthly_rent = B25064_001)

# Total population
POPULATION <- get_acs_all_years("B01003_001") |>
    rename(population = B01003_001)

# Total number of households
HOUSEHOLDS <- get_acs_all_years("B11001_001") |>
    rename(households = B11001_001)
    
    
    
get_building_permits <- function(start_year = 2009, end_year = 2023){
    fname <- glue("housing_units_{start_year}_{end_year}.csv")
    fname <- file.path("data", "mp02", fname)
    
    if(!file.exists(fname)){
        HISTORICAL_YEARS <- seq(start_year, 2018)
        
        HISTORICAL_DATA <- map(HISTORICAL_YEARS, function(yy){
            historical_url <- glue("https://www.census.gov/construction/bps/txt/tb3u{yy}.txt")
                
            LINES <- readLines(historical_url)[-c(1:11)]

            CBSA_LINES <- str_detect(LINES, "^[[:digit:]]")
            CBSA <- as.integer(str_sub(LINES[CBSA_LINES], 5, 10))

            PERMIT_LINES <- str_detect(str_sub(LINES, 48, 53), "[[:digit:]]")
            PERMITS <- as.integer(str_sub(LINES[PERMIT_LINES], 48, 53))
            
            data_frame(CBSA = CBSA,
                       new_housing_units_permitted = PERMITS, 
                       year = yy)
        }) |> bind_rows()
        
        CURRENT_YEARS <- seq(2019, end_year)
        
        CURRENT_DATA <- map(CURRENT_YEARS, function(yy){
            current_url <- glue("https://www.census.gov/construction/bps/xls/msaannual_{yy}99.xls")
            
            temp <- tempfile()
            
            download.file(current_url, destfile = temp, mode="wb")
            
            fallback <- function(.f1, .f2){
                function(...){
                    tryCatch(.f1(...), 
                             error=function(e) .f2(...))
                }
            }
            
            reader <- fallback(read_xlsx, read_xls)
            
            reader(temp, skip=5) |>
                na.omit() |>
                select(CBSA, Total) |>
                mutate(year = yy) |>
                rename(new_housing_units_permitted = Total)
        }) |> bind_rows()
        
        ALL_DATA <- rbind(HISTORICAL_DATA, CURRENT_DATA)
        
        write_csv(ALL_DATA, fname)
        
    }
    
    read_csv(fname, show_col_types=FALSE)
}

PERMITS <- get_building_permits()


ensure_package(httr2)
ensure_package(rvest)
get_bls_industry_codes <- function(){
    fname <- fname <- file.path("data", "mp02", "bls_industry_codes.csv")
    
    if(!file.exists(fname)){
    
        resp <- request("https://www.bls.gov") |> 
            req_url_path("cew", "classifications", "industry", "industry-titles.htm") |>
            req_headers(`User-Agent` = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:143.0) Gecko/20100101 Firefox/143.0") |> 
            req_error(is_error = \(resp) FALSE) |>
            req_perform()
        
        resp_check_status(resp)
        
        naics_table <- resp_body_html(resp) |>
            html_element("#naics_titles") |> 
            html_table() |>
            mutate(title = str_trim(str_remove(str_remove(`Industry Title`, Code), "NAICS"))) |>
            select(-`Industry Title`) |>
            mutate(depth = if_else(nchar(Code) <= 5, nchar(Code) - 1, NA)) |>
            filter(!is.na(depth))
        
        naics_table <- naics_table |> 
            filter(depth == 4) |> 
            rename(level4_title=title) |> 
            mutate(level1_code = str_sub(Code, end=2), 
                   level2_code = str_sub(Code, end=3), 
                   level3_code = str_sub(Code, end=4)) |>
            left_join(naics_table, join_by(level1_code == Code)) |>
            rename(level1_title=title) |>
            left_join(naics_table, join_by(level2_code == Code)) |>
            rename(level2_title=title) |>
            left_join(naics_table, join_by(level3_code == Code)) |>
            rename(level3_title=title) |>
            select(-starts_with("depth")) |>
            rename(level4_code = Code) |>
            select(level1_title, level2_title, level3_title, level4_title, 
                   level1_code,  level2_code,  level3_code,  level4_code)
    
        write_csv(naics_table, fname)
    }
    
    read_csv(fname, show_col_types=FALSE)
    
}

INDUSTRY_CODES <- get_bls_industry_codes()


ensure_package(httr2)
ensure_package(rvest)
get_bls_qcew_annual_averages <- function(start_year=2009, end_year=2023){
    fname <- glue("bls_qcew_{start_year}_{end_year}.csv.gz")
    fname <- file.path("data", "mp02", fname)
    
    YEARS <- seq(start_year, end_year)
    YEARS <- YEARS[YEARS != 2020] # Drop Covid year to match ACS
    
    if(!file.exists(fname)){
        ALL_DATA <- map(YEARS, .progress=TRUE, possibly(function(yy){
            fname_inner <- file.path("data", "mp02", glue("{yy}_qcew_annual_singlefile.zip"))
            
            if(!file.exists(fname_inner)){
                request("https://www.bls.gov") |> 
                    req_url_path("cew", "data", "files", yy, "csv",
                                 glue("{yy}_annual_singlefile.zip")) |>
                    req_headers(`User-Agent` = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:143.0) Gecko/20100101 Firefox/143.0") |> 
                    req_retry(max_tries=5) |>
                    req_perform(fname_inner)
            }
            
            if(file.info(fname_inner)$size < 755e5){
                warning(sQuote(fname_inner), "appears corrupted. Please delete and retry this step.")
            }
            
            read_csv(fname_inner, 
                     show_col_types=FALSE) |> 
                mutate(YEAR = yy) |>
                select(area_fips, 
                       industry_code, 
                       annual_avg_emplvl, 
                       total_annual_wages, 
                       YEAR) |>
                filter(nchar(industry_code) <= 5, 
                       str_starts(area_fips, "C")) |>
                filter(str_detect(industry_code, "-", negate=TRUE)) |>
                mutate(FIPS = area_fips, 
                       INDUSTRY = as.integer(industry_code), 
                       EMPLOYMENT = as.integer(annual_avg_emplvl), 
                       TOTAL_WAGES = total_annual_wages) |>
                select(-area_fips, 
                       -industry_code, 
                       -annual_avg_emplvl, 
                       -total_annual_wages) |>
                # 10 is a special value: "all industries" , so omit
                filter(INDUSTRY != 10) |> 
                mutate(AVG_WAGE = TOTAL_WAGES / EMPLOYMENT)
        })) |> bind_rows()
        
        write_csv(ALL_DATA, fname)
    }
    
    ALL_DATA <- read_csv(fname, show_col_types=FALSE)
    
    ALL_DATA_YEARS <- unique(ALL_DATA$YEAR)
    
    YEARS_DIFF <- setdiff(YEARS, ALL_DATA_YEARS)
    
    if(length(YEARS_DIFF) > 0){
        stop("Download failed for the following years: ", YEARS_DIFF, 
             ". Please delete intermediate files and try again.")
    }
    
    ALL_DATA
}

WAGES <- get_bls_qcew_annual_averages()
```

## Data Integration and Initial Exploration



### Extra Credit Opportunity #01: Relationship Diagram

The diagram below summarizes the structure of the datasets used in this project and the relationships among them.

![](images/diagram2.png){width="90%" fig-align="center"}

Each dataset in this project represents a distinct source of information related to housing affordability, and the diagram above shows the logical connections among them.

- **ACS Tables â€” INCOME, RENT, POPULATION, and HOUSEHOLDS:**  
  These datasets share the geographic identifier `GEOID` and the variable `year`.  
  These common keys allow one-to-one joins, aligning indicators such as median household income, monthly rent, population size, and number of households for each metropolitan area and each year.

- **PERMITS (Building Permits Survey):**  
  Uses the `CBSA` code to identify the same metropolitan areas.  
  While `CBSA` and `GEOID` are not identical, they represent equivalent regional boundaries and can be cross-referenced to connect new housing construction data with ACS demographic measures.

- **WAGES (Bureau of Labor Statistics):**  
  Uses the `FIPS` code to identify regions and includes variables for total employment, total wages, and average annual wage by industry (`INDUSTRY`).  
  Each `INDUSTRY` code link has a detailed description in the **INDUSTRY_CODES** table.

- **INDUSTRY_CODES (Lookup Table):**  
  Provides hierarchical industry classification labels that map the numeric codes in the WAGES dataset to descriptive names.

Put together, all these relationships show how multiple data sources with different identifiers (`GEOID`, `CBSA`, `FIPS`) and time references (`year`) can be integrated.  
Although the data are not fully normalizedâ€”some relationships, we have enough to study how income, rent, housing supply, and wage dynamics interact across U.S. metropolitan areas over time.

### Multi-Table Questions

**1.Which CBSA (by name) permitted the largest number of new housing units in the decade from 2010 to 2019 (inclusive)?**

```{r}
largest_cbsa <- PERMITS %>%
  filter(year >= 2010 & year <= 2019) %>%
  group_by(CBSA) %>%
  summarize(total_permits = sum(new_housing_units_permitted, na.rm = TRUE)) %>%
  arrange(desc(total_permits)) %>%
  left_join(HOUSEHOLDS, by = c("CBSA" = "GEOID")) %>%
  slice(1) %>%
  select(NAME, total_permits)

highlight <- function(x) {
  paste0('<span style="color: darkred;"><b>', x, '</b></span>')
}
```

The CBSA that permitted the largest number of new housing units in the decade from 2010 to 2019 (inclusive) is `r highlight(largest_cbsa$NAME)`, which permitted `r highlight(largest_cbsa$total_permits)` new housing units.

**2.In what year did Albuquerque, NM (CBSA Number 10740) permit the most new housing units?**

```{r}
  housing_permits<- PERMITS %>%
    filter(CBSA == 10740) %>%
    arrange(desc(new_housing_units_permitted)) %>%
    slice(1) %>%
    select(year, new_housing_units_permitted)
```
Abuquerque, NM (CBSA Number 10740) issued the most new housing units in the year of `r highlight(housing_permits$year)`, for a total of `r highlight(housing_permits$new_housing_units_permitted)`.

**3.Which state (not CBSA) had the highest average individual income in 2015? To answer this question, you will need to first compute the total income per CBSA by multiplying the average household income by the number of households, and then sum total income and total population across all CBSAs in a state. With these numbers, you can answer this question.**

```{r}
   library(stringr)
  
  INCOME %>%
    filter(year == 2015) %>%
    mutate(state = str_extract(NAME, "., ([A-Z]{2})", group = 1)) %>%
    left_join(HOUSEHOLDS %>% filter(year == 2015) %>% select(GEOID, households), 
              by = "GEOID") %>%
    mutate(total_income = household_income * households) %>%
    group_by(state) %>%
    summarize(total_income = sum(total_income, na.rm = TRUE),
              total_households = sum(households, na.rm = TRUE)) %>%
    mutate(avg_individual_income = total_income / total_households) %>%
    arrange(desc(avg_individual_income)) %>%
    slice(1) %>%
    select(state, avg_individual_income)
```

**4.Data scientists and business analysts are recorded under NAICS code 5182. What is the last year in which the NYC CBSA had the most data scientists in the country? In recent, the San Francisco CBSA has had the most data scientists.**


```{r}

library(dplyr)

# Filter WAGES data for data scientists (NAICS 5182) first
wages_filtered <- WAGES |>
  filter(INDUSTRY == 5182) |>
  mutate(std_cbsa = paste0(FIPS, "0"))

# Filter POPULATION data and prepare for join
population_filtered <- POPULATION |>
  mutate(std_cbsa = paste0("C", GEOID))

# Join the datasets on std_cbsa and year
data_scientists <- wages_filtered |>
  inner_join(
    population_filtered |> select(std_cbsa, NAME, year),
    by = c("std_cbsa" = "std_cbsa", "YEAR" = "year")
  )

# Group by year and CBSA to find which had the most data scientists
ds_by_year <- data_scientists |>
  group_by(YEAR, NAME) |>
  summarise(total_employment = sum(EMPLOYMENT, na.rm = TRUE), .groups = "drop") |>
  group_by(YEAR) |>
  slice_max(total_employment, n = 1) |>
  ungroup() |>
  arrange(desc(YEAR))

# Find the last year NYC had the most data scientists
last_nyc_year <- ds_by_year |>
  filter(grepl("New York", NAME, ignore.case = TRUE)) |>
  pull(YEAR) |>
  max()


# Filter to show only NYC area rows
nyc_only <- ds_by_year |>
  filter(grepl("New York", NAME, ignore.case = TRUE))
print(nyc_only)
```

The last year in which the NYC CBSA had the most data scientists in the country was `r highlight(last_nyc_year)`.

**5. What fraction of total wages in the NYC CBSA was earned by people employed in the finance and insurance industries (NAICS code 52)? In what year did this fraction peak?**

```{r}
#  Step 1: Filter WAGES data before joining
wages_filtered <- WAGES |>
  mutate(std_cbsa = paste0(FIPS, "0"))

# Step 2: Filter POPULATION data and prepare for join
population_filtered <- POPULATION |>
  mutate(std_cbsa = paste0("C", GEOID)) |>
  filter(grepl("New York", NAME, ignore.case = TRUE))

# Step 3: Join to get NYC data only
nyc_wages <- wages_filtered |>
  inner_join(
    population_filtered |> select(std_cbsa, NAME, year),
    by = c("std_cbsa" = "std_cbsa", "YEAR" = "year")
  )

# Step 4: Calculate total wages by year for NYC
total_wages_by_year <- nyc_wages |>
  group_by(YEAR) |>
  summarise(total_wages = sum(TOTAL_WAGES, na.rm = TRUE), .groups = "drop")

# Step 5: Calculate finance and insurance (NAICS 52) wages by year for NYC
finance_wages_by_year <- nyc_wages |>
  filter(INDUSTRY == 52) |>
  group_by(YEAR) |>
  summarise(finance_wages = sum(TOTAL_WAGES, na.rm = TRUE), .groups = "drop")

# Step 6: Join and calculate the fraction
finance_fraction <- total_wages_by_year |>
  inner_join(finance_wages_by_year, by = "YEAR") |>
  mutate(fraction = finance_wages / total_wages) |>
  arrange(YEAR)


# Find the year with the peak fraction
peak_year <- finance_fraction |>
  slice_max(fraction, n = 1)

```

The fraction of total wages in the NYC CBSA earned by people employed in the finance and insurance industries The fraction of total wages in the NYC CBSA earned by people employed in the finance and insurance industries peaked in the year `r highlight(peak_year$YEAR[[1]])`, with a fraction of `r highlight(round(peak_year$fraction[[1]] * 100, 2))`%.

### Initial Visualizations

**1. The relationship between monthly rent and average household income per CBSA in 2009 using ggplot**
```{r}
library(ggplot2)
income_rent_2009 <- INCOME %>%
  filter(year == 2009) %>%
  inner_join(RENT %>% filter(year == 2009), by = c("GEOID", "year"))
ggplot(income_rent_2009, aes(x = household_income, y = monthly_rent)) +
  geom_point(color = "blue", alpha = 0.6) +
  labs(title = "Monthly Rent vs. Average Household Income (2009)",
       x = "Average Household Income",
       y = "Monthly Rent") +
  theme_bw()
```



**2. The relationship between total employment and total employment in the health care and social services sector (NAICS 62) across different CBSAs. Design your visualization so that it is possible to see the evolution of this relationship over time.**

```{r}
library(dplyr)
library(ggplot2)

#  Step 1: Filter WAGES data for healthcare (NAICS 62) before joining
healthcare_wages <- WAGES |>
  filter(INDUSTRY == 62) |>
  mutate(std_cbsa = paste0(FIPS, "0")) |>
  group_by(std_cbsa, YEAR) |>
  summarise(healthcare_employment = sum(EMPLOYMENT, na.rm = TRUE), .groups = "drop")

# Step 2: Calculate total employment by CBSA and year
total_employment <- WAGES |>
  mutate(std_cbsa = paste0(FIPS, "0")) |>
  group_by(std_cbsa, YEAR) |>
  summarise(total_employment = sum(EMPLOYMENT, na.rm = TRUE), .groups = "drop")

# Step 3: Join healthcare and total employment data
employment_data <- total_employment |>
  inner_join(healthcare_wages, by = c("std_cbsa", "YEAR")) |>
  inner_join(
    POPULATION |> mutate(std_cbsa = paste0("C", GEOID)) |> select(std_cbsa, NAME, year),
    by = c("std_cbsa" = "std_cbsa", "YEAR" = "year")
  ) |>
  mutate(healthcare_share = healthcare_employment / total_employment)

ggplot(employment_data, aes(x = total_employment, y = healthcare_employment, color = YEAR)) +
  geom_point(alpha = 0.6, size = 2) +
  geom_smooth(method = "lm", se = FALSE, alpha = 0.3) +
  facet_wrap(~YEAR, scales = "free") +
  scale_x_log10(labels = scales::comma) +
  scale_y_log10(labels = scales::comma) +
  labs(
    title = "Relationship Between Total Employment and Healthcare Employment by CBSA",
    subtitle = "Evolution over time across different years",
    x = "Total Employment (log scale)",
    y = "Healthcare & Social Services Employment (log scale)",
    color = "Year"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    legend.position = "bottom"
  )

```


**3. The evolution of average household size over time. Use different lines to represent different CBSAs. For each plot, make sure your final visualization is publication-ready and equipped with, at a minimum.**

- Proper x and y-axis axis labels
- A meaningful title
- Proper units for axis ticks (if appropriate)
- Proper legend titles (if appropriate)
- Proper font sizes so that all text is legible.


```{r}
library(dplyr)
library(ggplot2)
library(scales)

# --- Build CBSAâ€“year totals from WAGES ---
health_emp <- WAGES %>%
  group_by(YEAR, FIPS) %>%
  summarise(
    total_emp  = sum(EMPLOYMENT, na.rm = TRUE),
    health_emp = sum(EMPLOYMENT[INDUSTRY == 62], na.rm = TRUE),
    .groups = "drop"
  ) %>%
  filter(total_emp > 0) %>%                      # keep valid rows
  mutate(std_cbsa = paste0(FIPS, "0"))           # to match Census IDs

# (optional) add CBSA names for nicer plots/tooltips/filters
cbsa_names <- POPULATION %>%
  mutate(std_cbsa = paste0("C", GEOID)) %>%
  distinct(std_cbsa, NAME)

health_emp <- health_emp %>% left_join(cbsa_names, by = "std_cbsa")



ggplot(health_emp, aes(x = total_emp, y = health_emp)) +
  geom_point(alpha = 0.55) +
  scale_x_log10(labels = comma) +
  scale_y_log10(labels = comma) +
  facet_wrap(~ YEAR, ncol = 4) +
  labs(
    title = "Health Care & Social Services vs Total Employment across CBSAs",
    subtitle = "Each panel is a year; log scales show the relationship across city sizes",
    x = "Total employment (log scale)",
    y = "Health care & social services employment (log scale)"
  ) +
  theme_minimal()


ggplot(health_emp, aes(total_emp, health_emp, group = std_cbsa)) +
  geom_path(aes(color = YEAR), alpha = 0.25, linewidth = 0.6) +
  geom_point(aes(color = YEAR), alpha = 0.25, size = 0.7) +
  scale_x_log10(labels = comma) +
  scale_y_log10(labels = comma) +
  scale_color_viridis_c(option = "plasma", guide = guide_colorbar(title = "Year")) +
  labs(
    title = "Evolution of Health Sector Employment vs Total Employment",
    subtitle = "Each path is a CBSA moving through time",
    x = "Total employment (log scale)",
    y = "Health care & social services employment (log scale)"
  ) +
  theme_minimal()

```
## Building Indices of Housing Affordability and Housing Stock Growth

We will begin by constructing an initial metric of rent affordability by combining our INCOME, RENT, and POPULATION tables from above. Using a suitable join, we merge these three into a single table which can be used to perform the following task.

### Rent Burden

**Standardization:** Define a baseline value around which your metric is centered.  
Some possible baseline structures may include:

- Setting 0, 50, or 100 to the long-term national average  
- Setting 0, 50, or 100 to the national average in the first year of your study  
- Setting 0 to the lowest value and 100 to the highest value in the study


```{r}
# Load required libraries
library(dplyr)

# Step 1: Join INCOME and RENT tables
rent_burden_raw <- INCOME |>
  inner_join(
    RENT,
    by = c("GEOID" = "GEOID", "year" = "year"),
    suffix = c("_income", "_rent")
  ) |>
  select(GEOID, NAME_income, year, household_income, monthly_rent) |>
  rename(NAME = NAME_income)

# Step 2: Calculate basic rent-to-income ratio
# Annualize monthly rent and compute ratio
rent_burden_raw <- rent_burden_raw |>
  mutate(
    annual_rent = monthly_rent * 12,
    raw_rent_to_income = annual_rent / household_income
  )

# Step 3: Calculate national baseline (long-term average across all years and CBSAs)
national_baseline <- rent_burden_raw |>
  summarise(mean_rent_to_income = mean(raw_rent_to_income, na.rm = TRUE)) |>
  pull(mean_rent_to_income)

cat("National baseline rent-to-income ratio:", round(national_baseline, 4), "\n\n")

# Step 4: Create standardized rent burden index
rent_burden_data <- rent_burden_raw |>
  mutate(
    # Standardized index (50 = national average)
    rent_burden_index = (raw_rent_to_income / national_baseline) * 50,
    
    # Classification for interpretation
    burden_level = case_when(
      rent_burden_index < 30 ~ "Very Low",
      rent_burden_index < 40 ~ "Low",
      rent_burden_index < 50 ~ "Below Average",
      rent_burden_index < 60 ~ "Above Average",
      rent_burden_index < 70 ~ "High",
      TRUE ~ "Very High"
    )
  ) |>
  select(GEOID, NAME, year, household_income, monthly_rent, 
         annual_rent, raw_rent_to_income, rent_burden_index, burden_level) |>
  arrange(year, rent_burden_index)

# Display summary statistics
cat("Rent Burden Index Summary Statistics:\n")
cat("=====================================\n")
cat("Min:", round(min(rent_burden_data$rent_burden_index, na.rm = TRUE), 2), "\n")
cat("Q1:", round(quantile(rent_burden_data$rent_burden_index, 0.25, na.rm = TRUE), 2), "\n")
cat("Median:", round(median(rent_burden_data$rent_burden_index, na.rm = TRUE), 2), "\n")
cat("Mean:", round(mean(rent_burden_data$rent_burden_index, na.rm = TRUE), 2), "\n")
cat("Q3:", round(quantile(rent_burden_data$rent_burden_index, 0.75, na.rm = TRUE), 2), "\n")
cat("Max:", round(max(rent_burden_data$rent_burden_index, na.rm = TRUE), 2), "\n\n")

# Show examples of high and low burden CBSAs
cat("Top 10 Highest Rent Burden (most recent year):\n")
print(
  rent_burden_data |>
    filter(year == max(year)) |>
    slice_max(rent_burden_index, n = 10) |>
    select(NAME, year, household_income, monthly_rent, rent_burden_index, burden_level)
)

cat("\n\nTop 10 Lowest Rent Burden (most recent year):\n")
print(
  rent_burden_data |>
    filter(year == max(year)) |>
    slice_min(rent_burden_index, n = 10) |>
    select(NAME, year, household_income, monthly_rent, rent_burden_index, burden_level)
)

# Display the full dataset
cat("\n\nFull Rent Burden Dataset:\n")
print(rent_burden_data)
```

